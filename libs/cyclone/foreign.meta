;; This file was automatically generated by the Cyclone Scheme compiler
((c-define lambda (expr rename compare) (let* ((scm-fnc (cadr expr)) (scm-fnc-wrapper (gensym (quote scm-fnc))) (c-fnc (cadddr expr)) (rv-type (caddr expr)) (rv-cust-type (eval (quasiquote (with-handler (lambda X #f) (hash-table-ref *foreign-types* (quote (unquote rv-type))))))) (rv-cust-convert (if (and rv-cust-type (= 3 (length rv-cust-type))) (caddr rv-cust-type) #f)) (arg-types (cddddr expr)) (arg-cust-convert #f) (arg-syms/unbox (map (lambda (type) (let ((var (mangle (gensym (quote arg)))) (arg-cust-type (eval (quasiquote (with-handler (lambda X #f) (hash-table-ref *foreign-types* (quote (unquote type)))))))) (cons var (scm->c var (cond (arg-cust-type (if (> (length arg-cust-type) 1) (set! arg-cust-convert #t)) (car arg-cust-type)) (else type)))))) arg-types)) (returns (c->scm (string-append c-fnc "(" (string-join (map cdr arg-syms/unbox) ",") ")") (if rv-cust-type (car rv-cust-type) rv-type))) (return-alloc (car returns)) (return-expr (cdr returns)) (args (string-append "(void *data, int argc, closure _, object k " (apply string-append (map (lambda (sym/unbox) (string-append ", object " (car sym/unbox))) arg-syms/unbox)) ")")) (body (string-append return-alloc "return_closcall1(data, k, " return-expr ");"))) (cond ((or rv-cust-convert arg-cust-convert) (if (not rv-cust-convert) (set! rv-cust-convert (quote begin))) (let ((arg-syms (map (lambda (type) (let* ((sym (gensym (quote arg))) (arg-cust-type (eval (quasiquote (with-handler (lambda X #f) (hash-table-ref *foreign-types* (quote (unquote type))))))) (pass-arg (if (and arg-cust-type (> (length arg-cust-type) 1)) (quasiquote ((unquote (cadr arg-cust-type)) (unquote sym))) sym))) (cons sym pass-arg))) arg-types))) (quasiquote (begin (define-c (unquote scm-fnc-wrapper) (unquote args) (unquote body)) (define ((unquote scm-fnc) (unquote-splicing (map car arg-syms))) ((unquote rv-cust-convert) ((unquote scm-fnc-wrapper) (unquote-splicing (map cdr arg-syms))))))))) (else (quasiquote (define-c (unquote scm-fnc) (unquote args) (unquote body))))))) (c->scm lambda (expr rename compare) (let ((code (cadr expr)) (type (caddr expr))) (quasiquote (case (if (string? (unquote type)) (string->symbol (unquote type)) (unquote type)) ((int integer) (cons "" (string-append "obj_int2obj(" (unquote code) ")"))) ((float double) (let ((var (mangle (gensym (quote var))))) (cons (string-append "make_double(" var ", " (unquote code) ");") (string-append "&" var)))) ((bool) (cons "" (string-append "(" (unquote code) " == 0 ? boolean_f : boolean_t)"))) ((char) (cons "" (string-append "obj_char2obj(" (unquote code) ")"))) ((string) (let ((var (mangle (gensym (quote var))))) (cons (string-append "make_utf8_string(data," var ", " (unquote code) ");") (string-append "&" var)))) (else (error "c->scm unable to convert C object of type " (unquote type))))))) (scm->c lambda (expr rename compare) (let ((code (cadr expr)) (type (caddr expr))) (quasiquote (case (unquote type) ((int integer) (string-append "obj_obj2int(" (unquote code) ")")) ((double float) (string-append "double_value(" (unquote code) ")")) ((bignum bigint) (string-append "bignum_value(" (unquote code) ")")) ((bool) (string-append "(" (unquote code) " == boolean_f)")) ((char) (string-append "obj_obj2char(" (unquote code) ")")) ((string) (string-append "string_str(" (unquote code) ")")) ((symbol) (string-append "symbol_desc(" (unquote code) ")")) ((bytevector) (string-append "(((bytevector_type *)" (unquote code) ")->data)")) ((opaque) (string-append "opaque_ptr(" (unquote code) ")")) (else (error "scm->c unable to convert scheme object of type " (unquote type))))))) (c-code lambda (expr rename compare) (for-each (lambda (arg) (if (not (string? arg)) (error "c-code" "Invalid argument: string expected, received " arg))) (cdr expr)) (quasiquote (Cyc-foreign-code (unquote-splicing (cdr expr))))) (c-value lambda (expr rename compare) (let* ((code-arg (cadr expr)) (type-arg (caddr expr)) (c-type (eval (quasiquote (with-handler (lambda X #f) (hash-table-ref *foreign-types* (quote (unquote type-arg))))))) (c-ret-convert #f)) (when c-type (set! type-arg (car c-type)) (if (= 3 (length c-type)) (set! c-ret-convert (caddr c-type)))) (if c-ret-convert (quasiquote ((lambda () ((unquote c-ret-convert) (Cyc-foreign-value (unquote code-arg) (unquote (symbol->string type-arg))))))) (quasiquote ((lambda () (Cyc-foreign-value (unquote code-arg) (unquote (symbol->string type-arg))))))))) (c-define-type lambda (expr rename compare) (let ((name (cadr expr)) (type (cddr expr))) (unless (eval (quote (with-handler (lambda X #f) *foreign-types*))) (eval (quasiquote (define *foreign-types* (make-hash-table))))) (eval (quasiquote (hash-table-set! *foreign-types* (quote (unquote name)) (quote (unquote type))))) #f)))